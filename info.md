### Описание работы приложения
 -  Все хранится в базе данных sqlite3.
 -  Сертфиикаты шифруются и сохраняются в базе.
 -  При запуске приложения запрашивается пароль для расшифровки ключа, он расшифровывается и сохраняется в переменной для использования функциями приложения.
  
 -  Генерируется корневой CA сертфикат, которым подписываются все сертификаты, вклчая промежуточные CA сертификаты. Ключ корневого сертификата хранится в базе данных в зашифрованном виде и не выгружается. Все остальные сертфиикаты включая промежуточный можно
 выгрузить.



### Запуск приложения


- Задачи:
    - [X] Проверка создания всех таблиц в базе данных (если не созданы)
    - [X] Генерация ключа и сертификата tlss на локальном сервере для подключения к серверам (если не создан), сохраняется стандартно в .ssh директорию пользователя.
    - [X] Если ключ шифрования не создан то запрашиваем данные ключа, шифруем паролем и сохраняем в базу данных
    - [X] Запускается проверка доступности серверов добавленных в базу данных (данные периода опроса брать из конфигурационного файла)
  
### Раздел Add server

- Задачи:
  - [X] Добавляем возможность добавления сервера в базу данных, проверяем наличие открытого ключа на уделнном сервере в authorized_keys и если его нет, то выполняем копирование открытого ключа сервиса tlss на удаленный сервер. 
  - [X] Добавить возможность удалять  серверы из базы данных с подтверждением удаления.

###  Раздел Add certs

- Задачи:
  - [ ] Разработаь форму добавления сертификата.
  - [ ] Генерация x509 (версия openssl?) сертфиикатов с разными параметрами и добавления к выбранному сервер  https://vulnerx.com/ssh-key-algorithms/
    - [ ] RSA
  
      Основан на задаче факторизации больших чисел
      Использует модульную арифметику для шифрования и дешифрования
      Ключи обычно имеют размер 2048 бит или больше
      Алгоритм относительно медленный, особенно для больших ключей
    
    - [ ] ECDSA (Эллиптическая криптография)
        Требуется выбор элиптической кривой (prime256v1, secp384r1 и т.д.)
      
      
    - [ ] Ed25519 (Эллиптическая криптография)
        Не требуется выбор кривой — ED25519 использует фиксированную кривую Edwards 25519, которая встроена в сам алгоритм.
     
  - [ ] Выгрузка (конвертация) сертфиикатов в формате pkcs12-контейнер (взять готовые сертфиикаты и ключи, задать к ним пароль и выгрузить), pem-текстовый, der-бинарник
  - [ ] Создание mTLS для разных клиентов

### Ведение логов работы приложения 
1. Записывать логи и ошибки в файл
    - [ ] Разделять логи для каждого сервера?
    - [ ] Записывать логи и ошибки в файл


## Subject Alternative Name (SAN)
- **Назначение**: Указывает альтернативные имена субъекта сертификата
- **Формат**: `subjectAltName = DNS:example.com, DNS:www.example.com, IP:192.168.1.1, email:admin@example.com`
- **Важность**: Критическое расширение для современных TLS-сертификатов, позволяет защищать несколько доменов одним сертификатом
- **Пример в OpenSSL**: `subjectAltName=DNS:example.com,DNS:*.example.com`

## Basic Constraints
- **Назначение**: Определяет, является ли сертификат CA (удостоверяющим центром)
- **Параметры**:
  - `CA:TRUE/FALSE` - может ли сертификат выпускать другие сертификаты
  - `pathLenConstraint` - максимальное количество промежуточных CA в цепочке
- **Пример**: `basicConstraints=critical,CA:FALSE` (для конечных сертификатов)
- **Пример CA**: `basicConstraints=critical,CA:TRUE,pathlen:0`

## Key Usage
- **Назначение**: Определяет разрешенные операции с ключом
- **Значения**:
  - `digitalSignature` - для подписи данных
  - `nonRepudiation` - для неотрекаемости
  - `keyEncipherment` - для шифрования ключей
  - `dataEncipherment` - для шифрования данных
  - `keyAgreement` - для обмена ключами
  - `keyCertSign` - для подписи сертификатов (CA)
  - `cRLSign` - для подписи списков отзыва
- **Пример**: `keyUsage=critical,digitalSignature,keyEncipherment`

## Extended Key Usage
- **Назначение**: Уточняет конкретные сценарии использования сертификата
- **Значения**:
  - `serverAuth` - аутентификация веб-сервера (TLS/SSL)
  - `clientAuth` - аутентификация клиента
  - `codeSigning` - подпись кода
  - `emailProtection` - защита электронной почты
  - `timeStamping` - службы меток времени
  - `OCSPSigning` - подпись OCSP-ответов
- **Пример**: `extendedKeyUsage=serverAuth,clientAuth`

## Certificate Policies
- **Назначение**: Указывает политики, применимые к сертификату
- **Содержимое**: OID политик сертификации
- **Пример**: `certificatePolicies=1.2.3.4.5,1.2.3.4.6`

## CRL Distribution Points
- **Назначение**: Указывает, где найти список отзыва сертификатов (CRL)
- **Формат**: URL, где опубликован CRL
- **Пример**: `crlDistributionPoints=URI:http://crl.example.com/ca.crl`

## Authority Information Access (AIA)
- **Назначение**: Предоставляет информацию о CA и службах проверки статуса
- **Содержимое**:
  - `OCSP` - URL для проверки статуса по OCSP
  - `caIssuers` - URL для скачивания сертификата CA
- **Пример**: `authorityInfoAccess=OCSP;URI:http://ocsp.example.com,caIssuers;URI:http://example.com/ca.crt`

## Name Constraints
- **Назначение**: Ограничивает области DNS/email, для которых CA может выпускать сертификаты
- **Применение**: Используется в корпоративных и частных CA
- **Пример**: `nameConstraints=permitted;DNS:.example.com,excluded;DNS:.public.example.com`

## Subject Key Identifier
- **Назначение**: Уникальный идентификатор открытого ключа субъекта
- **Формат**: Хеш открытого ключа
- **Пример**: `subjectKeyIdentifier=hash`

## Authority Key Identifier
- **Назначение**: Идентификатор ключа издателя, помогает идентифицировать точный ключ CA
- **Пример**: `authorityKeyIdentifier=keyid,issuer`

## Практические рекомендации
- Для веб-серверов важны: SAN, keyUsage, extendedKeyUsage
- Для CA необходимы: basicConstraints(CA:TRUE), keyUsage(keyCertSign,cRLSign)
- Critical расширения должны поддерживаться всеми приложениями, иначе сертификат отклоняется


Будем генерировать на основе входящих данных при выборе метода rsa сертификат, сертфиикат должен быть подписан промежуточным CA сертфиикатом который лежит в базе данных в таблице sub_ca_tlss в зашифрованном виде, ключ для расшифровки взять из переменной crypts.AesSecretKey.Key. Сгенерированный сертфикат записываем в базу данных 